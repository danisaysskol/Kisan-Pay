CREATE TABLE IF NOT EXISTS public.customers
(
    cust_id integer NOT NULL DEFAULT nextval('customers_cust_id_seq'::regclass),
    cnic character varying(15) COLLATE pg_catalog."default" NOT NULL,
    u_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    pass character varying(255) COLLATE pg_catalog."default" NOT NULL,
    f_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    l_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    phone character varying(15) COLLATE pg_catalog."default" NOT NULL,
    email character varying(100) COLLATE pg_catalog."default" NOT NULL,
    role character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT customers_pkey PRIMARY KEY (cust_id),
    CONSTRAINT customers_cnic_key UNIQUE (cnic),
    CONSTRAINT unique_cnic UNIQUE (cnic),
    CONSTRAINT unique_email UNIQUE (email)
)

CREATE INDEX IF NOT EXISTS idx_customers_cust_id
    ON public.customers USING btree
    (cust_id ASC NULLS LAST)
    TABLESPACE pg_default;


CREATE TABLE IF NOT EXISTS public.accounts
(
    acc_no bigint NOT NULL DEFAULT nextval('accounts_acc_no_seq'::regclass),
    balance numeric(10,2) NOT NULL,
    cust_id integer NOT NULL,
    CONSTRAINT accounts_pkey PRIMARY KEY (acc_no),
    CONSTRAINT accounts_cust_id_fkey FOREIGN KEY (cust_id)
        REFERENCES public.customers (cust_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)


CREATE TABLE IF NOT EXISTS public.employees
(
    employee_id integer NOT NULL DEFAULT nextval('employees_employee_id_seq'::regclass),
    username character varying(50) COLLATE pg_catalog."default" NOT NULL,
    cnic character varying(15) COLLATE pg_catalog."default" NOT NULL,
    phone character varying(15) COLLATE pg_catalog."default" NOT NULL,
    email character varying(100) COLLATE pg_catalog."default" NOT NULL,
    password character varying(255) COLLATE pg_catalog."default" NOT NULL,
    f_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    l_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    "position" character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT employees_pkey PRIMARY KEY (employee_id),
    CONSTRAINT employees_cnic_key UNIQUE (cnic),
    CONSTRAINT employees_username_key UNIQUE (username)
)




CREATE TABLE IF NOT EXISTS public.manager
(
    employee_id integer NOT NULL,
    f_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    l_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT manager_pkey PRIMARY KEY (employee_id),
    CONSTRAINT manager_employee_id_fkey FOREIGN KEY (employee_id)
        REFERENCES public.employees (employee_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)


CREATE TABLE IF NOT EXISTS public.loans
(
    loan_id integer NOT NULL DEFAULT nextval('loans_loan_id_seq'::regclass),
    loan_amt numeric(10,2) NOT NULL,
    acc_no bigint NOT NULL,
    manager_id integer NOT NULL,
    start_date date,
    due_date date,
    CONSTRAINT loans_pkey PRIMARY KEY (loan_id),
    CONSTRAINT loans_acc_no_fkey FOREIGN KEY (acc_no)
        REFERENCES public.accounts (acc_no) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;




CREATE TABLE IF NOT EXISTS public.orders
(
    order_id integer NOT NULL DEFAULT nextval('sales_sale_id_seq'::regclass),
    buyer_id integer NOT NULL,
    order_date timestamp without time zone NOT NULL,
    total_price numeric(10,2) NOT NULL,
    CONSTRAINT sales_pkey PRIMARY KEY (order_id),
    CONSTRAINT sales_cust_id_fkey FOREIGN KEY (buyer_id)
        REFERENCES public.customers (cust_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)


TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.orderdetails
(
    order_detail_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    order_id integer NOT NULL,
    buyer_id integer NOT NULL,
    supplier_id integer NOT NULL,
    inventory_id integer NOT NULL,
    quantity integer NOT NULL,
    price numeric(10,2) NOT NULL,
    total_price numeric(10,2) NOT NULL GENERATED ALWAYS AS (((quantity)::numeric * price)) STORED,
    CONSTRAINT "orderDetails_pkey" PRIMARY KEY (order_detail_id)
)

TABLESPACE pg_default;


CREATE TABLE IF NOT EXISTS public.products
(
    product_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    base_price numeric(10,2),
    product_id integer NOT NULL DEFAULT nextval('products_product_id_seq'::regclass),
    CONSTRAINT products_pkey PRIMARY KEY (product_id)
)

TABLESPACE pg_default;

CREATE TABLE IF NOT EXISTS public.product_audit_log
(
    log_id integer NOT NULL,
    action_type character varying(10) COLLATE pg_catalog."default",
    product_id integer,
    product_name character varying(255) COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    base_price numeric(10,2),
    entry_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT product_audit_log_pkey PRIMARY KEY (log_id)
)

TABLESPACE pg_default;
----------
-- FUNCTION: public.log_product_changes()

-- DROP FUNCTION IF EXISTS public.log_product_changes();

CREATE OR REPLACE FUNCTION public.log_product_changes()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
	
BEGIN
    -- Handle INSERT
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO product_audit_log (
            action_type,
            product_id,
            product_name,
            description,
            base_price,
            entry_date
        )
        VALUES (
            'INSERT',
            NEW.product_id,
            NEW.product_name,
            NEW.description,
            NEW.base_price,
            CURRENT_TIMESTAMP
        );
    
    -- Handle UPDATE
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO product_audit_log (
            action_type,
            product_id,
            product_name,
            description,
            base_price,
            entry_date
        )
        VALUES (
            'UPDATE',
            NEW.product_id,
            NEW.product_name,
            NEW.description,
            NEW.base_price,
            CURRENT_TIMESTAMP
        );
    
    -- Handle DELETE
    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO product_audit_log (
            action_type,
            product_id,
            product_name,
            description,
            base_price,
            entry_date
        )
        VALUES (
            'DELETE',
            OLD.product_id,
            OLD.product_name,
            OLD.description,
            OLD.base_price,
            CURRENT_TIMESTAMP
        );
    END IF;

    RETURN NULL; 
END;
$BODY$;

------------


CREATE OR REPLACE TRIGGER products_audit_trigger
    AFTER INSERT OR DELETE OR UPDATE 
    ON public.products
    FOR EACH ROW
    EXECUTE FUNCTION public.log_product_changes();

-----------------




CREATE TABLE IF NOT EXISTS public.inventory
(
    inventory_id integer NOT NULL,
    supplier_id integer NOT NULL,
    product_id integer NOT NULL,
    quantity integer NOT NULL,
    price integer NOT NULL,
    CONSTRAINT inventory_pkey PRIMARY KEY (inventory_id),
    CONSTRAINT inventory_product_id_fkey FOREIGN KEY (product_id)
        REFERENCES public.products (product_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
        NOT VALID
)




----------------
--transactions

-- Table: public.transactions

-- DROP TABLE IF EXISTS public.transactions;

CREATE TABLE IF NOT EXISTS public.transactions
(
    transaction_id bigint NOT NULL,
    acc_no bigint NOT NULL,
    date_time timestamp without time zone NOT NULL,
    transfer_to bigint,
    amount numeric(10,2) NOT NULL,
    sender_id integer,
    receiver_id integer,
    CONSTRAINT transactions_pkey PRIMARY KEY (transaction_id),
    CONSTRAINT fk_receiver FOREIGN KEY (receiver_id)
        REFERENCES public.customers (cust_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT fk_sender FOREIGN KEY (sender_id)
        REFERENCES public.customers (cust_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT transactions_acc_no_fkey FOREIGN KEY (acc_no)
        REFERENCES public.accounts (acc_no) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT transactions_transfer_to_fkey FOREIGN KEY (transfer_to)
        REFERENCES public.accounts (acc_no) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;
-- DROP INDEX IF EXISTS public.idx_transactions_date_time;

CREATE INDEX IF NOT EXISTS idx_transactions_date_time
    ON public.transactions USING btree
    (date_time ASC NULLS LAST)
    TABLESPACE pg_default;
-- Index: idx_transactions_receiver_id

-- DROP INDEX IF EXISTS public.idx_transactions_receiver_id;

CREATE INDEX IF NOT EXISTS idx_transactions_receiver_id
    ON public.transactions USING btree
    (receiver_id ASC NULLS LAST)
    TABLESPACE pg_default;
-- Index: idx_transactions_sender_id

-- DROP INDEX IF EXISTS public.idx_transactions_sender_id;

CREATE INDEX IF NOT EXISTS idx_transactions_sender_id
    ON public.transactions USING btree
    (sender_id ASC NULLS LAST)
    TABLESPACE pg_default;































